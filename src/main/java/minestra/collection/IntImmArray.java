package minestra.collection;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.OptionalInt;
import java.util.Random;
import java.util.function.IntBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.IntFunction;
import java.util.function.IntPredicate;
import java.util.function.IntSupplier;
import java.util.function.IntToDoubleFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.stream.IntStream;

/**
 * An immutable array of primitive <code>int</code>.
 */
public interface IntImmArray {

    /**
     * Returns a new array of the specified values.
     * @param a int array
     * @return new array
     */
    static IntImmArray of(int... a) {
        return new IntImmArrayImpl(a);
    }

    /**
     * Returns a new array of the specified values.
     * @param collection collection
     * @return new array
     */
    static IntImmArray of(Collection<Integer> collection) {
        return ImmArray.of(collection).mapToInt(Integer::intValue);
    }

    /**
     * Returns a new array of the specified values.
     * @param stream stream
     * @return new array
     */
    static IntImmArray of(IntStream stream) {
        return of(stream.toArray());
    }

    /**
     * Returns a new array of generating with specified size and generator.
     * @param size array size to generate
     * @param generator generator
     * @return the array
     */
    static IntImmArray generate(int size, IntSupplier generator) {
        int[] a = new int[size];
        for (int i = 0; i < size; i++) {
            a[i] = generator.getAsInt();
        }
        return of(a);
    }

    /**
     * Returns a new array of generating with the specified range.
     * @param start start of range
     * @param end end of range
     * @return the array
     */
    static IntImmArray range(int start, int end) {
        final int length = end - start + 1;
        if (length <= 0) {
            throw new IllegalArgumentException(String.format("illegal range: %d to %d", start, end));
        }
        int[] a = new int[length];
        for (int i = 0; i < length; i++) {
            a[i] = start + i;
        }
        return of(a);
    }

    /**
     * Returns a new array of generating with the specified range and the specified step.
     * @param start start of range
     * @param end inclusive end of range
     * @param step step
     * @return the array
     */
    static IntImmArray range(int start, int end, int step) {
        final int length;
        if (step == 0) {
            length = -1;
        }
        else if (step < 0) {
            length = (start - end) / (-step) + 1;
        }
        else {
            length = (end - start) / step + 1;
        }
        if (length <= 0) {
            throw new IllegalArgumentException(String.format("illegal range: %d to %d step %d", start, end, step));
        }
        int[] a = new int[length];
        for (int i = 0; i < length; i++) {
            a[i] = start + i * step;
        }
        return of(a);
    }

    /**
     * Returns the array of values which are generated by {@link Random}.
     * If it is necessary to use secure random, use <code>generate(int, IntSupplier)</code> with secure random API.
     * @param size array size
     * @param min minimum value
     * @param max maximum value
     * @return the array
     */
    static IntImmArray random(int size, int min, int max) {
        final int distance = max - min + 1;
        Random r = new Random(System.currentTimeMillis());
        int[] a = new int[size];
        for (int i = 0; i < size; i++) {
            a[i] = min + (int) (r.nextDouble() * distance);
        }
        return of(a);
    }

    /**
     * Returns the array as code points of specified <code>CharSequence</code>.
     * @param s instance of <code>CharSequence</code>
     * @return the array
     */
    static IntImmArray asCodePoints(CharSequence s) {
        return of(s.codePoints());
    }

    /**
     * Returns the concatenated array of all specified arrays.
     * @param first the first array
     * @param rest the rest of arrays
     * @return the concatenated array
     */
    default IntImmArray concat(IntImmArray first, IntImmArray... rest) {
        final int selfLength = size();
        final int firstLength = first.size();
        int newLength = selfLength;
        newLength += firstLength;
        for (IntImmArray o : rest) {
            newLength += o.size();
        }
        int[] a = Arrays.copyOf(toArray(), newLength);
        int p = selfLength;
        System.arraycopy(first.toArray(), 0, a, p, firstLength);
        p += firstLength;
        for (IntImmArray o : rest) {
            final int length = o.size();
            System.arraycopy(o.toArray(), 0, a, p, length);
            p += length;
        }
        return of(a);
    }

    /**
     * Returns the number of elements in this array.
     * @return the number of elements
     */
    int size();

    /**
     * Returns the element at the specified index in this array.
     * @param index index of an desired element
     * @return the element
     */
    int at(int index);

    /**
     * Returns an empty array.
     * @return the empty array
     */
    static IntImmArray empty() {
        return IntImmArrayImpl.EMPTY;
    }

    /**
     * Performs apply function as an action to each element of this array.
     * @param action action to apply to each element
     */
    default void forEach(IntConsumer action) {
        final int n = size();
        for (int i = 0; i < n; i++) {
            action.accept(at(i));
        }
    }

    /**
     * Returns whether this array is empty.
     * @return <code>true</code> if this is empty.
     */
    default boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns whether the element which satisfies predicate exists in this array.
     * @param pred predicate
     * @return <code>true</code> if the element exists
     */
    default boolean exists(IntPredicate pred) {
        final int n = size();
        for (int i = 0; i < n; i++) {
            if (pred.test(at(i))) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns whether this array contains the element which is same as specified element.
     * @param value value to find
     * @return <code>true</code> if this array contains specified element
     */
    default boolean contains(int value) {
        final int n = size();
        for (int i = 0; i < n; i++) {
            if (at(i) == value) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns an optional value which satisfies specified predicate from the beginning in this array.
     * @param pred predicate
     * @return the optional value
     */
    default OptionalInt find(IntPredicate pred) {
        return find(pred, 0);
    }

    /**
     * Returns an optional value which satisfies specified predicate after the specified index in this array.
     * @param pred predicate
     * @param start number of beginning index to find
     * @return the element as an optional value
     */
    default OptionalInt find(IntPredicate pred, int start) {
        final int n = size();
        for (int i = start; i < n; i++) {
            final int value = at(i);
            if (pred.test(value)) {
                return OptionalInt.of(value);
            }
        }
        return OptionalInt.empty();
    }

    /**
     * Returns the index of first element which is same as specified value in this array.
     * @param value value to find
     * @return number of the index, returns <code>-1</code> if not found
     */
    default int indexOf(int value) {
        final int n = size();
        for (int i = 0; i < n; i++) {
            if (at(i) == value) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Returns the index of element which is the first match of the specified predicate in this array.
     * @param pred predicate
     * @return number of the index, returns <code>-1</code> if not found
     */
    default int indexWhere(IntPredicate pred) {
        final int n = size();
        for (int i = 0; i < n; i++) {
            if (pred.test(at(i))) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Returns the first element of this array if it is not empty.
     * @return the first element as an optional value
     */
    default OptionalInt head() {
        return (size() == 0) ? OptionalInt.empty() : OptionalInt.of(at(0));
    }

    /**
     * Returns the tail elements of this array if exists.
     * @return the tail elements as an array
     */
    default IntImmArray tail() {
        return slice(1, Integer.MAX_VALUE);
    }

    /**
     * Returns a new array of elements that taken out the specified number of from the beginning of this array.
     * @param count count to take
     * @return the array
     */
    default IntImmArray take(int count) {
        return (count == 0) ? empty() : slice(0, count - 1);
    }

    /**
     * Returns a new array of elements that taken out while specified predicate matches from the beginning of this array.
     * @param pred predicate
     * @return the array
     */
    default IntImmArray takeWhile(IntPredicate pred) {
        final int index = indexWhere(pred.negate());
        return (index > 0) ? slice(0, index - 1) : empty();
    }

    /**
     * Returns the rest of the array that drops the specified number of elements in this array.
     * @param count count to drop
     * @return the array
     */
    default IntImmArray drop(int count) {
        final int n = size();
        return (count >= n) ? empty() : slice(count, n);
    }

    /**
     * Returns the rest of the array that drops elements which the specified predicate matches in this array.
     * @param pred predicate
     * @return the array
     */
    default IntImmArray dropWhile(IntPredicate pred) {
        final int index = indexWhere(pred.negate());
        return (index >= 0) ? drop(index) : empty();
    }

    /**
     * Returns the slice of this array.
     * @param from inclusive index of first
     * @param to exclusive index of end
     * @return the array
     */
    default IntImmArray slice(int from, int to) {
        final int n = size() - 1;
        final int to0 = (to < n) ? to : n;
        return of(Arrays.copyOfRange(toArray(), from, to0 + 1));
    }

    /**
     * Returns an array created by applying a function to each of the elements of this array.
     * @param mapper function as a mapper
     * @return the array
     */
    default IntImmArray map(IntUnaryOperator mapper) {
        final int n = size();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = mapper.applyAsInt(at(i));
        }
        return of(a);
    }

    /**
     * Returns an object array created by applying a function to each of the elements of this array.
     * @param <R> type of result array elements
     * @param mapper function as a mapper
     * @return the mapped array
     */
    default <R> ImmArray<R> mapToObj(IntFunction<R> mapper) {
        final int n = size();
        List<R> a = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            a.add(mapper.apply(at(i)));
        }
        return ImmArray.of(a);
    }

    /**
     * Returns a long array created by applying a function to each of the elements of this array.
     * @param mapper function as a mapper
     * @return the mapped array
     */
    default LongImmArray mapToLong(IntToLongFunction mapper) {
        final int n = size();
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = mapper.applyAsLong(at(i));
        }
        return LongImmArray.of(a);
    }

    /**
     * Returns a double array created by applying a function to each of the elements of this array.
     * @param mapper function as a mapper
     * @return the mapped array
     */
    default DoubleImmArray mapToDouble(IntToDoubleFunction mapper) {
        final int n = size();
        double[] a = new double[n];
        for (int i = 0; i < n; i++) {
            a[i] = mapper.applyAsDouble(at(i));
        }
        return DoubleImmArray.of(a);
    }

    /**
     * Returns an object array created by applying boxing to each element in this array.
     * @return the object array
     */
    default ImmArray<Integer> boxed() {
        return mapToObj(Integer::valueOf);
    }

    /**
     * Returns the result that reduce elements of this array with the specified binary operator.
     * @param op binary operator
     * @return the result as optional, or optional empty if this array is empty
     */
    default OptionalInt reduce(IntBinaryOperator op) {
        final int n = size();
        if (n == 0) {
            return OptionalInt.empty();
        }
        int result = at(0);
        for (int i = 1; i < n; i++) {
            result = op.applyAsInt(result, at(i));
        }
        return OptionalInt.of(result);
    }

    /**
     * Returns the result that reduce elements of this array with the specified binary operator.
     * @param identity identity element
     * @param op binary operator
     * @return the result
     */
    default int reduce(int identity, IntBinaryOperator op) {
        final int n = size();
        if (n == 0) {
            return identity;
        }
        int result = identity;
        for (int i = 0; i < n; i++) {
            result = op.applyAsInt(result, at(i));
        }
        return result;
    }

    /**
     * Returns the result of folding the elements of this array by the specified operator.
     * @param value initial value
     * @param f binary operator
     * @return the result
     */
    default int fold(int value, IntBinaryOperator f) {
        switch (size()) {
            case 0:
                return value;
            case 1:
                return f.applyAsInt(value, at(0));
            default:
                return f.applyAsInt(value, tail().fold(at(0), f));
        }
    }

    /**
     * Returns a new array which consists with unique elements.
     * @return the array
     */
    default IntImmArray distinct() {
        return of(IntStream.of(toArray()).distinct());
    }

    /**
     * Returns the result of filtering the elements of this array by specified predicate.
     * @param pred predicate
     * @return the array
     */
    default IntImmArray filter(IntPredicate pred) {
        final int n = size();
        int p = 0;
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            int x = at(i);
            if (pred.test(x)) {
                a[p++] = x;
            }
        }
        return new IntImmArrayImpl(Arrays.copyOf(a, p));
    }

    /**
     * Returns the sum of elements in this array.
     * @return the sum
     */
    int sum();

    /**
     * Returns the product of elements in this array.
     * @return the product
     */
    int product();

    /**
     * Returns the mean value of elements in this array.
     * If this stream is empty, returns empty optional.
     * @return the mean value
     */
    default double average() {
        return sum() * 1d / size();
    }

    /**
     * Returns a maximum value as optional in this array.
     * If this stream is empty, returns empty optional.
     * @return the maximum value
     */
    OptionalInt max();

    /**
     * Returns a minimum value as optional in this array.
     * If this stream is empty, returns empty optional.
     * @return the minimum value
     */
    OptionalInt min();

    /**
     * Returns new array which is sorted this array in natural order.
     * @return the sorted array
     */
    default IntImmArray sort() {
        int[] a = toArray();
        Arrays.sort(a);
        return of(a);
    }

    /**
     * Returns new array which is sorted this array with specified order.
     * @param cmp order
     * @return the sorted array
     */
    default IntImmArray sortWith(IntComparator cmp) {
        return sortWith(0, size() - 1, cmp);
    }

    /**
     * Returns new array which is sorted this array with specified order.
     * @param fromIndex from
     * @param toIndex to
     * @param cmp order
     * @return the sorted array
     */
    IntImmArray sortWith(int fromIndex, int toIndex, IntComparator cmp);

    /**
     * Returns new array which is reversed the order of elements in this array.
     * @return the array
     */
    default IntImmArray reverse() {
        int[] a = toArray();
        final int size = a.length;
        final int n = a.length / 2;
        for (int i = 0, j = size - 1; i < n; i++, j--) {
            int x = a[j];
            a[j] = a[i];
            a[i] = x;
        }
        return of(a);
    }

    /**
     * Returns this array as a native array.
     * @return the array
     */
    int[] toArray();

    /**
     * Returns the stream which consist same elements in this array.
     * @return the stream
     */
    default IntStream stream() {
        return IntStream.of(toArray());
    }

    /**
     * Returns the result that this operation converts this array into string, as code points.
     * @return string
     */
    default String toStringAsCodePoints() {
        return new String(toArray(), 0, size());
    }

    /**
     * Returns new array as code points that this array is replaced by the replacement character.
     * @param target target to replace
     * @param replacement replacement character
     * @return the array
     */
    default IntImmArray replaceCodePoint(char target, char replacement) {
        final int cp0 = target;
        final int cp1 = replacement;
        return map(x -> x == cp0 ? cp1 : x);
    }

    /**
     * Returns new array as code points that this array is replaced by the replacement character.
     * @param chars target and replacement
     * @return the array
     */
    default IntImmArray replaceCodePoint(String chars) {
        int[] codePoints = chars.codePoints().toArray();
        final int cp0 = codePoints[0];
        final int cp1 = codePoints[1];
        return map(x -> x == cp0 ? cp1 : x);
    }

}
